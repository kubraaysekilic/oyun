<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cozy Kitty Jump</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Quicksand:wght@400;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #FFF5F8 0%, #F0E6FF 50%, #E6F7FF 100%);
            font-family: 'Quicksand', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        .game-container {
            text-align: center;
        }

        h1 {
            color: #E8A0BF;
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 0px #fff, 0 0 20px rgba(232, 160, 191, 0.3);
            font-weight: 700;
        }

        .score-board {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-bottom: 15px;
        }

        .score-item {
            color: #9B8AA5;
            font-size: 1.2rem;
            font-weight: 600;
        }

        .score-item span {
            color: #B4D4E7;
            font-weight: bold;
            font-size: 1.4rem;
        }

        #gameCanvas {
            border: 4px solid #E8A0BF;
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(232, 160, 191, 0.25), 
                        0 0 0 8px rgba(255, 255, 255, 0.5);
        }

        .instructions {
            color: #9B8AA5;
            margin-top: 15px;
            font-size: 1rem;
        }

        .instructions kbd {
            background: linear-gradient(135deg, #FFE5EC 0%, #E6F7FF 100%);
            padding: 5px 12px;
            border-radius: 8px;
            border: 2px solid #E8A0BF;
            color: #9B8AA5;
            font-family: inherit;
            font-weight: 600;
        }

        #startMessage {
            position: absolute;
            color: #9B8AA5;
            font-size: 1.5rem;
            text-shadow: 2px 2px 0px #fff;
            pointer-events: none;
            font-weight: 600;
        }

        #gameOverMessage {
            display: none;
            position: absolute;
            color: #E8A0BF;
            font-size: 2rem;
            text-shadow: 2px 2px 0px #fff;
            pointer-events: none;
            font-weight: 700;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>üê± Cozy Kitty Jump ÔøΩ</h1>
        <div class="score-board">
            <div class="score-item">Score: <span id="score">0</span></div>
            <div class="score-item">High Score: <span id="highScore">0</span></div>
        </div>
        <div style="position: relative; display: inline-block;">
            <canvas id="gameCanvas" width="800" height="300"></canvas>
            <div id="startMessage">Press SPACE or Click to Start!</div>
            <div id="gameOverMessage">Game Over! Press SPACE to Restart</div>
        </div>
        <p class="instructions">Press <kbd>SPACE</kbd> or <kbd>Click</kbd> to Jump</p>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('highScore');
        const startMessage = document.getElementById('startMessage');
        const gameOverMessage = document.getElementById('gameOverMessage');

        // Game state
        let gameRunning = false;
        let gameOver = false;
        let score = 0;
        let highScore = localStorage.getItem('jumpRunnerHighScore') || 0;
        highScoreElement.textContent = highScore;

        // Ground
        const groundY = 250;

        // Cat player
        const player = {
            x: 80,
            y: groundY - 50,
            width: 50,
            height: 50,
            velocityY: 0,
            jumping: false,
            color: '#FFB5C5',
            innerColor: '#FFC8D6',
            eyeColor: '#2D2D2D',
            noseColor: '#E8A0BF',
            blushColor: 'rgba(255, 182, 193, 0.5)'
        };

        // Flowers decoration
        let flowers = [];
        for (let i = 0; i < 8; i++) {
            flowers.push({
                x: Math.random() * canvas.width,
                y: groundY + 10 + Math.random() * 30,
                size: Math.random() * 8 + 6,
                color: ['#FFB5C5', '#B4D4E7', '#C9B1FF', '#FFFACD'][Math.floor(Math.random() * 4)]
            });
        }

        // Gravity and jump
        const gravity = 0.8;
        const jumpForce = -15;

        // Obstacles
        let obstacles = [];
        let obstacleTimer = 0;
        let obstacleInterval = 100;
        let gameSpeed = 5;

        // Clouds for decoration
        let clouds = [
            { x: 100, y: 50, width: 80, height: 40 },
            { x: 300, y: 80, width: 60, height: 30 },
            { x: 550, y: 40, width: 100, height: 50 },
            { x: 750, y: 70, width: 70, height: 35 }
        ];

        // Ground decoration
        let groundLines = [];
        for (let i = 0; i < 20; i++) {
            groundLines.push({ x: i * 50, width: Math.random() * 30 + 10 });
        }

        function drawBackground() {
            // Soft pastel sky gradient
            const skyGradient = ctx.createLinearGradient(0, 0, 0, groundY);
            skyGradient.addColorStop(0, '#E6F7FF');
            skyGradient.addColorStop(0.5, '#FFF5F8');
            skyGradient.addColorStop(1, '#F0E6FF');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, groundY);

            // Soft sun with glow
            ctx.fillStyle = '#FFFACD';
            ctx.beginPath();
            ctx.arc(700, 60, 45, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFF8E7';
            ctx.beginPath();
            ctx.arc(700, 60, 35, 0, Math.PI * 2);
            ctx.fill();
            // Sun blush
            ctx.fillStyle = 'rgba(255, 182, 193, 0.3)';
            ctx.beginPath();
            ctx.arc(690, 65, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(710, 65, 8, 0, Math.PI * 2);
            ctx.fill();
            // Sun smile
            ctx.strokeStyle = '#E8A0BF';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(700, 62, 12, 0.1 * Math.PI, 0.9 * Math.PI);
            ctx.stroke();

            // Fluffy pastel clouds
            clouds.forEach(cloud => {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.ellipse(cloud.x, cloud.y, cloud.width / 2, cloud.height / 2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(cloud.x - cloud.width / 3, cloud.y + 5, cloud.width / 3, cloud.height / 2.5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(cloud.x + cloud.width / 3, cloud.y + 5, cloud.width / 3, cloud.height / 2.5, 0, 0, Math.PI * 2);
                ctx.fill();
                // Pink tint on clouds
                ctx.fillStyle = 'rgba(255, 213, 224, 0.3)';
                ctx.beginPath();
                ctx.ellipse(cloud.x, cloud.y + 5, cloud.width / 3, cloud.height / 3, 0, 0, Math.PI * 2);
                ctx.fill();
            });

            // Soft pastel ground
            const groundGradient = ctx.createLinearGradient(0, groundY, 0, canvas.height);
            groundGradient.addColorStop(0, '#C8E6C9');
            groundGradient.addColorStop(0.5, '#A8D5A2');
            groundGradient.addColorStop(1, '#8FBC8F');
            ctx.fillStyle = groundGradient;
            ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);

            // Cute grass tufts
            ctx.fillStyle = '#98D4A0';
            groundLines.forEach(line => {
                ctx.beginPath();
                ctx.moveTo(line.x, groundY);
                ctx.quadraticCurveTo(line.x + 3, groundY - 8, line.x + 6, groundY);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(line.x + 8, groundY);
                ctx.quadraticCurveTo(line.x + 11, groundY - 6, line.x + 14, groundY);
                ctx.fill();
            });

            // Draw flowers
            flowers.forEach(flower => {
                // Flower petals
                ctx.fillStyle = flower.color;
                for (let i = 0; i < 5; i++) {
                    ctx.beginPath();
                    const angle = (i * 72) * Math.PI / 180;
                    ctx.ellipse(
                        flower.x + Math.cos(angle) * flower.size * 0.4,
                        flower.y + Math.sin(angle) * flower.size * 0.4,
                        flower.size * 0.4,
                        flower.size * 0.4,
                        0, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
                // Flower center
                ctx.fillStyle = '#FFFACD';
                ctx.beginPath();
                ctx.arc(flower.x, flower.y, flower.size * 0.3, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawPlayer() {
            const px = player.x;
            const py = player.y;
            const pw = player.width;
            const ph = player.height;

            // Soft shadow
            ctx.fillStyle = 'rgba(200, 180, 200, 0.3)';
            ctx.beginPath();
            ctx.ellipse(px + pw / 2, groundY + 5, pw / 2 + 5, 8, 0, 0, Math.PI * 2);
            ctx.fill();

            // Cat ears
            ctx.fillStyle = player.color;
            // Left ear
            ctx.beginPath();
            ctx.moveTo(px + 5, py + 5);
            ctx.lineTo(px + 2, py - 15);
            ctx.lineTo(px + 18, py + 5);
            ctx.closePath();
            ctx.fill();
            // Right ear
            ctx.beginPath();
            ctx.moveTo(px + pw - 5, py + 5);
            ctx.lineTo(px + pw - 2, py - 15);
            ctx.lineTo(px + pw - 18, py + 5);
            ctx.closePath();
            ctx.fill();

            // Inner ears (pink)
            ctx.fillStyle = player.noseColor;
            ctx.beginPath();
            ctx.moveTo(px + 7, py + 3);
            ctx.lineTo(px + 5, py - 8);
            ctx.lineTo(px + 14, py + 3);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(px + pw - 7, py + 3);
            ctx.lineTo(px + pw - 5, py - 8);
            ctx.lineTo(px + pw - 14, py + 3);
            ctx.closePath();
            ctx.fill();

            // Cat body (rounded rectangle)
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.roundRect(px, py, pw, ph, 12);
            ctx.fill();

            // Body highlight
            ctx.fillStyle = player.innerColor;
            ctx.beginPath();
            ctx.roundRect(px + 8, py + 8, pw - 16, ph - 20, 8);
            ctx.fill();

            // Eyes (cute oval eyes)
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.ellipse(px + 15, py + 20, 9, 11, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(px + 35, py + 20, 9, 11, 0, 0, Math.PI * 2);
            ctx.fill();

            // Pupils
            ctx.fillStyle = player.eyeColor;
            ctx.beginPath();
            ctx.ellipse(px + 17, py + 21, 5, 7, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(px + 37, py + 21, 5, 7, 0, 0, Math.PI * 2);
            ctx.fill();

            // Eye sparkles
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(px + 15, py + 18, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(px + 35, py + 18, 2, 0, Math.PI * 2);
            ctx.fill();

            // Blush circles
            ctx.fillStyle = player.blushColor;
            ctx.beginPath();
            ctx.ellipse(px + 6, py + 28, 6, 4, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(px + 44, py + 28, 6, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Cute nose
            ctx.fillStyle = player.noseColor;
            ctx.beginPath();
            ctx.moveTo(px + 25, py + 28);
            ctx.lineTo(px + 22, py + 33);
            ctx.lineTo(px + 28, py + 33);
            ctx.closePath();
            ctx.fill();

            // Mouth (w shape for cat)
            ctx.strokeStyle = '#9B8AA5';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(px + 18, py + 37);
            ctx.quadraticCurveTo(px + 22, py + 40, px + 25, py + 36);
            ctx.quadraticCurveTo(px + 28, py + 40, px + 32, py + 37);
            ctx.stroke();

            // Whiskers
            ctx.strokeStyle = '#C9B1FF';
            ctx.lineWidth = 1.5;
            // Left whiskers
            ctx.beginPath();
            ctx.moveTo(px + 5, py + 30);
            ctx.lineTo(px - 8, py + 28);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(px + 5, py + 34);
            ctx.lineTo(px - 8, py + 36);
            ctx.stroke();
            // Right whiskers
            ctx.beginPath();
            ctx.moveTo(px + 45, py + 30);
            ctx.lineTo(px + 58, py + 28);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(px + 45, py + 34);
            ctx.lineTo(px + 58, py + 36);
            ctx.stroke();

            // Tail (when not jumping, show a cute curved tail)
            if (!player.jumping) {
                ctx.strokeStyle = player.color;
                ctx.lineWidth = 6;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(px + pw - 3, py + ph - 10);
                ctx.quadraticCurveTo(px + pw + 15, py + ph - 25, px + pw + 10, py + ph - 40);
                ctx.stroke();
            }
        }

        function drawObstacle(obstacle) {
            // Soft shadow
            ctx.fillStyle = 'rgba(200, 180, 200, 0.25)';
            ctx.beginPath();
            ctx.ellipse(obstacle.x + obstacle.width / 2, groundY + 5, obstacle.width / 2 + 3, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Cute mushroom obstacle
            const capHeight = obstacle.height * 0.6;
            const stemHeight = obstacle.height * 0.5;
            const capWidth = obstacle.width * 1.4;
            
            // Mushroom stem
            ctx.fillStyle = '#FFF5EE';
            ctx.beginPath();
            ctx.roundRect(
                obstacle.x + obstacle.width * 0.15,
                obstacle.y + capHeight - 5,
                obstacle.width * 0.7,
                stemHeight,
                [0, 0, 8, 8]
            );
            ctx.fill();

            // Stem highlight
            ctx.fillStyle = '#FFFAF5';
            ctx.beginPath();
            ctx.roundRect(
                obstacle.x + obstacle.width * 0.25,
                obstacle.y + capHeight,
                obstacle.width * 0.2,
                stemHeight - 10,
                4
            );
            ctx.fill();

            // Mushroom cap
            const capColors = ['#FFB5C5', '#B4D4E7', '#C9B1FF', '#FFFACD'];
            const capColor = capColors[Math.floor(obstacle.x) % 4];
            ctx.fillStyle = capColor;
            ctx.beginPath();
            ctx.ellipse(
                obstacle.x + obstacle.width / 2,
                obstacle.y + capHeight / 2,
                capWidth / 2,
                capHeight / 2,
                0, Math.PI, 0
            );
            ctx.fill();

            // Cap top curve
            ctx.beginPath();
            ctx.ellipse(
                obstacle.x + obstacle.width / 2,
                obstacle.y + capHeight / 2,
                capWidth / 2,
                capHeight / 2,
                0, 0, Math.PI * 2
            );
            ctx.fill();

            // Cute spots on cap
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.beginPath();
            ctx.arc(obstacle.x + obstacle.width * 0.3, obstacle.y + capHeight * 0.35, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(obstacle.x + obstacle.width * 0.7, obstacle.y + capHeight * 0.4, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(obstacle.x + obstacle.width * 0.5, obstacle.y + capHeight * 0.2, 3, 0, Math.PI * 2);
            ctx.fill();
        }

        function spawnObstacle() {
            const height = Math.random() * 30 + 40;
            const width = Math.random() * 15 + 25;
            obstacles.push({
                x: canvas.width,
                y: groundY - height,
                width: width,
                height: height
            });
        }

        function updatePlayer() {
            // Apply gravity
            player.velocityY += gravity;
            player.y += player.velocityY;

            // Ground collision
            if (player.y >= groundY - player.height) {
                player.y = groundY - player.height;
                player.velocityY = 0;
                player.jumping = false;
            }
        }

        function updateObstacles() {
            // Move obstacles
            obstacles.forEach(obstacle => {
                obstacle.x -= gameSpeed;
            });

            // Remove off-screen obstacles
            obstacles = obstacles.filter(obstacle => obstacle.x + obstacle.width > 0);

            // Spawn new obstacles
            obstacleTimer++;
            if (obstacleTimer >= obstacleInterval) {
                spawnObstacle();
                obstacleTimer = 0;
                // Randomize next spawn time
                obstacleInterval = Math.random() * 60 + 60;
            }
        }

        function updateClouds() {
            clouds.forEach(cloud => {
                cloud.x -= gameSpeed * 0.3;
                if (cloud.x + cloud.width < 0) {
                    cloud.x = canvas.width + cloud.width;
                    cloud.y = Math.random() * 80 + 30;
                }
            });
        }

        function updateGroundLines() {
            groundLines.forEach(line => {
                line.x -= gameSpeed;
                if (line.x + line.width < 0) {
                    line.x = canvas.width;
                    line.width = Math.random() * 30 + 10;
                }
            });
        }

        function updateFlowers() {
            flowers.forEach(flower => {
                flower.x -= gameSpeed * 0.5;
                if (flower.x + flower.size < 0) {
                    flower.x = canvas.width + flower.size;
                    flower.y = groundY + 10 + Math.random() * 30;
                    flower.color = ['#FFB5C5', '#B4D4E7', '#C9B1FF', '#FFFACD'][Math.floor(Math.random() * 4)];
                }
            });
        }

        function checkCollision() {
            for (let obstacle of obstacles) {
                if (player.x < obstacle.x + obstacle.width &&
                    player.x + player.width > obstacle.x &&
                    player.y < obstacle.y + obstacle.height &&
                    player.y + player.height > obstacle.y) {
                    return true;
                }
            }
            return false;
        }

        function jump() {
            if (!player.jumping && gameRunning && !gameOver) {
                player.velocityY = jumpForce;
                player.jumping = true;
            }
        }

        function startGame() {
            if (!gameRunning && !gameOver) {
                gameRunning = true;
                startMessage.style.display = 'none';
                gameLoop();
            } else if (gameOver) {
                resetGame();
            }
        }

        function resetGame() {
            gameOver = false;
            gameRunning = true;
            score = 0;
            gameSpeed = 5;
            obstacles = [];
            obstacleTimer = 0;
            player.y = groundY - player.height;
            player.velocityY = 0;
            player.jumping = false;
            scoreElement.textContent = '0';
            gameOverMessage.style.display = 'none';
            gameLoop();
        }

        function endGame() {
            gameOver = true;
            gameRunning = false;
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('jumpRunnerHighScore', highScore);
                highScoreElement.textContent = highScore;
            }
            gameOverMessage.style.display = 'block';
        }

        function gameLoop() {
            if (!gameRunning) return;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw background
            drawBackground();

            // Update game elements
            updatePlayer();
            updateObstacles();
            updateClouds();
            updateGroundLines();
            updateFlowers();

            // Draw obstacles
            obstacles.forEach(obstacle => drawObstacle(obstacle));

            // Draw player
            drawPlayer();

            // Check collision
            if (checkCollision()) {
                endGame();
                return;
            }

            // Update score
            score++;
            scoreElement.textContent = Math.floor(score / 10);

            // Increase difficulty over time
            if (score % 500 === 0 && gameSpeed < 12) {
                gameSpeed += 0.5;
            }

            requestAnimationFrame(gameLoop);
        }

        // Initial draw
        function initialDraw() {
            drawBackground();
            drawPlayer();
            startMessage.style.display = 'block';
            startMessage.style.top = '50%';
            startMessage.style.left = '50%';
            startMessage.style.transform = 'translate(-50%, -50%)';
            gameOverMessage.style.top = '50%';
            gameOverMessage.style.left = '50%';
            gameOverMessage.style.transform = 'translate(-50%, -50%)';
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (!gameRunning && !gameOver) {
                    startGame();
                } else if (gameOver) {
                    resetGame();
                } else {
                    jump();
                }
            }
        });

        canvas.addEventListener('click', () => {
            if (!gameRunning && !gameOver) {
                startGame();
            } else if (gameOver) {
                resetGame();
            } else {
                jump();
            }
        });

        // Touch support for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameRunning && !gameOver) {
                startGame();
            } else if (gameOver) {
                resetGame();
            } else {
                jump();
            }
        });

        // Initialize
        initialDraw();
    </script>
</body>
</html>

